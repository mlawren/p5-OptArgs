# Generated by Class::Inline version 0.0.1
# Date: Mon Oct  3 17:29:06 2022
use strict;
use warnings;

package OptArgs2::OptArgBase_CI;                              #CIFILTER#
use Class::Inline::Check                                      #CIFILTER#
  file        => '/home/mark/src/optargs/lib/OptArgs2.pm',    #CIFILTER#
  strip       => 1,                                           #CIFILTER#
  tidy        => 0,                                           #CIFILTER#
  wrap        => 0,                                           #CIFILTER#
  wrap_indent => 0,                                           #CIFILTER#
  wrap_maxlen => 78,                                          #CIFILTER#
  code        => <<'CIFILTER';                                #CIFILTER#

package OptArgs2::OptArgBase;our$_HAS;sub OptArgs2::OptArgBase_CI::import {shift;$_HAS={@_ > 1 ? @_ : %{$_[0]}};$_HAS=$_HAS->{'has'}if exists$_HAS->{'has'}}sub __RO {my (undef,undef,undef,$sub)=caller(1);Carp::croak("attribute $sub is read-only")}sub __CHECK {if (my@missing=grep {not exists $_[0]->{$_}}'comment','isa','name'){Carp::croak('OptArgs2::OptArgBase attribute(s) required: ' .join(', ',@missing))}no strict 'refs';my$_attrs=*{ref($_[0]).'::_ATTRS'};map {delete$_attrs->{$_}}keys %$_HAS}sub comment {$_[0]->__RO($_[1])if @_ > 1;$_[0]{'comment'}}sub default {$_[0]->__RO($_[1])if @_ > 1;$_[0]{'default'}}sub getopt {$_[0]->__RO($_[1])if @_ > 1;$_[0]{'getopt'}}sub isa {$_[0]->__RO($_[1])if @_ > 1;$_[0]{'isa'}}sub isa_name {if (@_ > 1){$_[0]{'isa_name'}=$_[1];return $_[0]}$_[0]{'isa_name'}}sub name {$_[0]->__RO($_[1])if @_ > 1;$_[0]{'name'}}sub required {$_[0]->__RO($_[1])if @_ > 1;$_[0]{'required'}}sub show_default {$_[0]->__RO($_[1])if @_ > 1;$_[0]{'show_default'}}BEGIN {$INC{'OptArgs2/OptArgBase.pm'}=__FILE__}
sub _dump { #CIFILTER#
    my $self = shift; #CIFILTER#
    my $d = shift // 1; #CIFILTER#
    require Data::Dumper; #CIFILTER#
    no warnings 'once'; #CIFILTER#
    local $Data::Dumper::Indent = 1; #CIFILTER#
    local $Data::Dumper::Maxdepth = $d; #CIFILTER#
    local $Data::Dumper::Sortkeys = 1; #CIFILTER#
    my $x = Data::Dumper::Dumper($self); #CIFILTER#
    $x =~ s/.*?{/{/; #CIFILTER#
    $x =~ s/}.*?\n$/}/; #CIFILTER#
    my $i = 0; #CIFILTER#
    my @list; #CIFILTER#
    do { #CIFILTER#
        @list = caller( $i++ ); #CIFILTER#
    } until $list[3] eq __PACKAGE__ . '::_dump'; #CIFILTER#
    warn "$self $x at $list[1]:$list[2]\n"; #CIFILTER#
} #CIFILTER#
CIFILTER
1;
